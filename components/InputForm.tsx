import React, { useState, useEffect, useRef } from 'react';
import { CommentInput, Platform } from '../types';
import { PLATFORM_OPTIONS } from '../constants';
import { Zap, Shield, Sparkles, Wand2, RefreshCw } from 'lucide-react';

declare const chrome: any;

interface InputFormProps {
  onSubmit: (data: CommentInput) => void;
  isLoading: boolean;
}

const InputForm: React.FC<InputFormProps> = ({ onSubmit, isLoading }) => {
  const [formData, setFormData] = useState<CommentInput>({
    platform: Platform.LINKEDIN,
    post_text: '',
    author_handle: '',
    avoid_keywords: [],
    privacy_consent: true,
  });

  const [avoidKeywordInput, setAvoidKeywordInput] = useState('');
  const [isAutoDetecting, setIsAutoDetecting] = useState(false);
  const hasAutoGenerated = useRef(false);

  // Auto-Fetch Logic on Mount
  useEffect(() => {
    const detectContext = async () => {
      // Ensure we are in a chrome extension environment
      if (typeof chrome !== 'undefined' && chrome.tabs && chrome.scripting) {
        setIsAutoDetecting(true);
        try {
          const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
          
          if (tab?.id) {
            // Detect Platform from URL
            const url = tab.url || '';
            let detectedPlatform = Platform.LINKEDIN;
            if (url.includes('twitter.com') || url.includes('x.com')) detectedPlatform = Platform.X;
            else if (url.includes('instagram.com')) detectedPlatform = Platform.INSTAGRAM;
            else if (url.includes('facebook.com')) detectedPlatform = Platform.FACEBOOK;
            else if (url.includes('reddit.com')) detectedPlatform = Platform.REDDIT;

            // Execute Script to grab text
            const results = await chrome.scripting.executeScript({
              target: { tabId: tab.id },
              func: () => {
                // --- BROWSER CONTEXT SCRIPT ---
                // Helper to clean text
                const clean = (txt: string) => txt.replace(/\s+/g, ' ').trim();

                // 1. Try User Selection first (highest intent)
                const selection = window.getSelection()?.toString();
                if (selection && selection.length > 10) return clean(selection);

                // 2. Platform Specific Heuristics
                const host = window.location.hostname;
                
                if (host.includes('linkedin')) {
                  // Find focused comment box, traverse up to find post
                  const active = document.activeElement;
                  if (active && active.tagName === 'DIV' && active.getAttribute('role') === 'textbox') {
                     const postContainer = active.closest('.feed-shared-update-v2');
                     const textEl = postContainer?.querySelector('.feed-shared-update-v2__description .update-components-text');
                     if (textEl) return clean((textEl as HTMLElement).innerText);
                  }
                  // Fallback: First visible post text
                  const firstPost = document.querySelector('.feed-shared-update-v2__description .update-components-text');
                  if (firstPost) return clean((firstPost as HTMLElement).innerText);
                }

                if (host.includes('twitter') || host.includes('x.com')) {
                   // Look for tweet text
                   const tweetText = document.querySelector('[data-testid="tweetText"]');
                   if (tweetText) return clean((tweetText as HTMLElement).innerText);
                }

                if (host.includes('reddit')) {
                   const postContent = document.querySelector('[data-test-id="post-content"]');
                   if (postContent) return clean((postContent as HTMLElement).innerText);
                }

                // 3. Fallback: Page meta description or body (risky, keep empty to be safe)
                return "";
                // --- END SCRIPT ---
              }
            });

            const fetchedText = results?.[0]?.result;

            if (fetchedText && fetchedText.length > 5) {
              setFormData(prev => ({
                ...prev,
                platform: detectedPlatform,
                post_text: fetchedText
              }));

              // AUTO-GENERATE if text is substantial and we haven't done it yet
              if (!hasAutoGenerated.current && fetchedText.length > 20) {
                 hasAutoGenerated.current = true;
                 // Small delay to let UI update state first
                 setTimeout(() => {
                   onSubmit({
                     ...formData,
                     platform: detectedPlatform,
                     post_text: fetchedText
                   });
                 }, 500);
              }
            }
          }
        } catch (e) {
          console.error("Auto-detect failed", e);
        } finally {
          setIsAutoDetecting(false);
        }
      }
    };

    detectContext();
  }, [onSubmit]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value, type } = e.target;
    if (type === 'checkbox') {
        setFormData((prev) => ({ ...prev, [name]: (e.target as HTMLInputElement).checked }));
    } else {
        setFormData((prev) => ({ ...prev, [name]: value }));
    }
  };

  const handlePlatformSelect = (platform: Platform) => {
    setFormData((prev) => ({ ...prev, platform }));
  };

  const handleAddKeyword = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && avoidKeywordInput.trim()) {
      e.preventDefault();
      setFormData((prev) => ({
        ...prev,
        avoid_keywords: [...(prev.avoid_keywords || []), avoidKeywordInput.trim()]
      }));
      setAvoidKeywordInput('');
    }
  };

  const removeKeyword = (index: number) => {
    setFormData((prev) => ({
      ...prev,
      avoid_keywords: prev.avoid_keywords?.filter((_, i) => i !== index)
    }));
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!formData.post_text.trim()) return;
    onSubmit(formData);
  };

  const handleManualGrab = () => {
     // Re-trigger the effect logic manually if needed, or just reload window
     window.location.reload(); 
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      
      {/* Platform Icons */}
      <div className="space-y-1.5">
        <label className="text-xs font-bold text-slate-500 uppercase tracking-wider">Platform</label>
        <div className="flex flex-wrap gap-1.5">
          {PLATFORM_OPTIONS.map((option) => (
            <button
              key={option.value}
              type="button"
              onClick={() => handlePlatformSelect(option.value)}
              className={`px-2.5 py-1.5 rounded-md text-[10px] font-bold uppercase transition-all border ${
                formData.platform === option.value
                  ? 'bg-slate-800 text-white border-slate-800 shadow-sm'
                  : 'bg-white border-slate-200 text-slate-500 hover:border-slate-300'
              }`}
            >
              {option.label}
            </button>
          ))}
        </div>
      </div>

      {/* Post Text */}
      <div className="space-y-1.5">
        <div className="flex justify-between items-center">
             <label htmlFor="post_text" className="text-xs font-bold text-slate-500 uppercase tracking-wider flex items-center gap-2">
              Post Content
              {isAutoDetecting && <span className="text-[9px] bg-indigo-50 text-indigo-600 px-1.5 py-0.5 rounded animate-pulse">Detecting...</span>}
            </label>
             <button type="button" onClick={handleManualGrab} className="text-[10px] text-indigo-600 hover:underline font-semibold flex items-center gap-1">
                <Wand2 className="w-3 h-3" /> Retry Auto-Fetch
             </button>
        </div>
        <textarea
          id="post_text"
          name="post_text"
          required
          rows={6}
          className="w-full px-3 py-2 rounded-lg border border-slate-200 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition-all text-xs resize-none bg-white shadow-sm"
          placeholder="Paste post text here (or let us auto-detect)..."
          value={formData.post_text}
          onChange={handleChange}
        />
      </div>

      {/* Collapsible/Compact Optional Fields */}
      <div className="space-y-3 pt-1">
         <div className="grid grid-cols-1 gap-3">
             <input
              type="text"
              name="author_handle"
              className="w-full px-3 py-2 rounded-lg border border-slate-200 focus:ring-2 focus:ring-indigo-500 text-xs"
              placeholder="@AuthorHandle (Optional)"
              value={formData.author_handle}
              onChange={handleChange}
            />
         </div>

        <div className="space-y-1">
          <input
            type="text"
            className="w-full px-3 py-2 rounded-lg border border-slate-200 text-xs"
            placeholder="Avoid words (Press Enter)..."
            value={avoidKeywordInput}
            onChange={(e) => setAvoidKeywordInput(e.target.value)}
            onKeyDown={handleAddKeyword}
          />
          {formData.avoid_keywords && formData.avoid_keywords.length > 0 && (
              <div className="flex flex-wrap gap-1 mt-1.5">
                {formData.avoid_keywords.map((kw, idx) => (
                    <span key={idx} className="bg-red-50 text-red-600 px-1.5 py-0.5 rounded text-[10px] font-medium border border-red-100 flex items-center gap-1">
                    {kw}
                    <button type="button" onClick={() => removeKeyword(idx)} className="hover:text-red-800 font-bold">&times;</button>
                    </span>
                ))}
            </div>
          )}
        </div>
      </div>

      <div className="flex items-start gap-2 pt-2">
          <input 
            type="checkbox" 
            id="privacy_consent" 
            name="privacy_consent"
            checked={formData.privacy_consent}
            onChange={handleChange}
            className="mt-0.5 w-3.5 h-3.5 text-indigo-600 rounded border-slate-300 focus:ring-indigo-500"
          />
          <label htmlFor="privacy_consent" className="text-[10px] text-slate-500 leading-tight select-none">
            I agree to process text for suggestions. No data stored.
          </label>
      </div>

      <button
        type="submit"
        disabled={isLoading || !formData.post_text || !formData.privacy_consent}
        className="w-full py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-xl font-bold text-sm shadow-md hover:shadow-lg transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2 mt-2"
      >
        {isLoading ? (
            <>
             <RefreshCw className="w-4 h-4 animate-spin" />
             Writing...
            </>
        ) : (
            <>
            <Zap className="w-4 h-4" />
            Generate Comments
            </>
        )}
      </button>
    </form>
  );
};

export default InputForm;